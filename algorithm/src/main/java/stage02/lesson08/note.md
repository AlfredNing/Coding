# 有序表

## 搜索二叉树

经典搜索二叉树，左树比他父节点小，右树比它大，没有重复值。

如果有重复值，每一个node里面增加数据项，表示出现次数实现。

- 查询：当前节点<value 向左移动，> 向右移动
- 增加：当前节点<value 向左移动，> 向右移动
- 改：先删再加
- 删除：
  - 没有左右节点，直接删除
  - 有左节点，无右节点，提升左节点
  - 有右节点，无左节点，提升右节点
  - 有右有左，查询右子树的最左节点，右子树提升到删除节点得父节点当中。

**搜索二叉树的问题**

#### **输入状况决定性能**

**自动平衡机制 ，出现了平衡搜索二叉树**

> 左旋/右旋 对哪一个节点进行倾斜

#### 左旋

![image-20220912121831801](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220912121831801.png)

#### 右旋

![image-20220912121735510](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220912121735510.png)

## 有序表

TreeMap : 底层是平衡二叉搜索树

有序表定义【规范、接口名】：key/有序数组 可排序，增删改查时间复杂度O(logN)

AVL, SB树，红黑树几乎无差别。**有差别的常数时间复杂度。**

AVL: |左高-右高| < 2

SB树：任何叔节点不少于任何一个侄子节点

![image-20220918092424270](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220918092424270.png)

红黑树：

- 节点非红既黑
- 头黑 叶黑
- 红节点子节点必须是黑节点
- ....

实际上是规范最长的链与最短的链长度不要超过一倍往上

AVL,SB,红黑：底层只会使用到左旋右旋的动作，动作的细节都是不一样。

![image-20220918093357795](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220918093357795.png)

## 寻找平衡性

从插入/删除节点从下往上检查受影响节点的平衡性![image-20220918093631850](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220918093631850.png)

SB树，红黑树都是寻找链都一样，只是在具体节点的时候不一样。

## AVL 调整

LL型，LR型，RL型，RR型，每个节点都是O(1)

![image-20220918111525737](http://ri2wb7ul3.hd-bkt.clouddn.com/note-img/image-20220918111525737.png)

## SB树好调整

# 有序表

有序表是接口名，只要能满足key有序，O(logN)都是有序表。Avl Sb树 红黑树几乎无差别

**平衡性**

- AVL: | 左高 - 右高 | < 2

- SB树： 任何一个叔节点不小于它的任何侄子树。隐含意思： 最多差2倍 + 1，基本高度是log(n)水平

- 红黑树：

  - 每个节点不是红就是黑
  - 头是黑节点，叶子是黑节点
  - 红节点的子节点一定是黑节点
  - 从任何一个节点到其子节点黑节点数量一样多

  **以上，红黑树都是在规定平衡性：每个节点往下的长度不超过2倍**

**不管AVL,SB树，红黑树都是有自己的策略调整平衡性，基本动作都是左旋与右旋**

都是从影响的节点出发，只是调整平衡性的动作不一样

- LL 
- LR
- RL
- RR

四种违规行为只会出现一种

| 左高 - 右高 | > 1 右树过长 R型，左树过长 L型

**x 左孩子节点 < [x r l]节点树 RL**

**x 左孩子节点 < [x r r]节点树 RR**

**x 右孩子节点 < [x L L]节点树 LL**

**x 右孩子节点 < [x L R]节点树 LR**

谁子发生变化，进行调整

# 跳表

可以做有序表的所有操作

**性能O(logN)实现机制与二叉树没有关系**

内部有一个Node,内部有多个指针指向

添加操作：

生成node节点，内部有node节点，node默认带有一条指正

math.random() <= 0.5 认为是0 加一指针

maht.random() > 0.5 认为是1 停止

# 红黑树

- 节点非红既黑

- 头结点与叶子节点都是黑节点

- 红节点得子节点不能是红节点

- 任何一个节点到叶子节点黑叶子的数量一样多

# 题目

## 题目1 - 不需要改写有序表

**给定一个二维数组，二维数组内的一维数组是排好序的**，请返回一个区间，区间跨度最小能够让每个一维数组的数都可以包括进来。

[ [1,2,3,3,4,5], [2,3,4,6,7]],[3,5] => [1,2] 或者[6,7]满足条件 ，结果返回[1,2]

求解过程：

准备一个有序表，

放入[1,2,3] =》最小区间 【1,3】

从每个一维数字开始端开始遍历：

有序表弹出最小的 =》 1

1 来自第1个一维数组，将之后的数据放入进去排序[2,2,3] =》 [2,3]

有序表在尝试每一个数字开头的时候，答案是什么



## 题目2 - 需要改写有序表 CountofRangeSum

![image-20221022174538284](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20221022174538284.png)

![image-20221022175737607](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20221022175737607.png)

## 题目3 - 需要改写有序表 SlidingWindowMedian

![image-20221022191339661](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20221022191339661.png)

# AC 自动机

## 文章包含的候选串 AcWord

前缀树：

![image-20221022195132980](http://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20221022195132980.png)

寻找最大的可能性。否定从0位置开始的可能性

每次到达一个节点，顺fail指正收集答案，存在结果收集答案。修改状态【描白】

