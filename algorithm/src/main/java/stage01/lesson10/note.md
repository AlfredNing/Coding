# 暴力递归
暴力递归就是尝试
1. 把问题转行为规模缩小了的同类问题的子问题
2. 有明确的不需要进行递归的条件（base case）
3. 有当得到了子问题的结果之后的决策过程
4. 不记录每一个子问题的解 == 暴力
## Dijkstra算法 Dijkstra
1. Dijkstra算法必须指定一个源点
2. 生成一个源点到各个点的最小距离表，一开始只有一条记录，即源点到自己的最小距离为0，
源点到其他所有点的最小记录都为正无穷大
3. 从距离表中拿出没拿过记录里的最小纪录，通过这个点发出的边，更新源点到各个点的最小距离表，不断重复这一步
4. 源点到所有的点记录如果都拿过一遍，过程停止，最小距离表得到了
**前提没有负数的边**
---
1. 汉诺塔问题 也被称为河内塔问题 Hanoi  
最优步数是 2^n - 1
2. 给你一个栈，逆序一个栈 ReverseStackUsingRecursive
不能申请额外的数据结构
只能使用递归函数
3. 打印一个字符串的全部子序列  stage01.lesson10.PrintAllSubsequence.subs
注意子序列≠子串 
4. 打印一个字符串的全部子序列，要求不出现重复的字面值的子序列  stage01.lesson10.PrintAllSubsequence.subsNoRepeat
5. 打印一个字符串的全部排列 stage01.lesson10.PrintAllPermutations.permutaions
6. 打印一个字符串的全部排列，要求不能出现重复的排列 stage01.lesson10.PrintAllPermutations.permutaions2
7. **从左到右的尝试模型1** ConvertToLetterString
规定1和A对应、2和B对应、3和C对应...
那么一个数字字符串比如"111"就可以转化为：
“AAA”,"KA","AK"
给定一个只有数字字符组成的字符串str,返回有多少种转化结果
隐含题意：0是没法转的
8. [从左](![](https://nq-bucket.oss-cn-shanghai.aliyuncs.com/note_img/image-20221119092759614.png))往右尝试模型2 Knapsack
给定两个长度都为N的数组weights和Values,
weight[i] 和values[i] 分别代表i号的物品的重量和价值
给定一个正数bag,表示一个载重bag的袋子，
你装的物品不能超过这个重量，返回你能装下的最多的价值的多少
9. 范围上尝试的模型 CardsInLine
给定一个整型数组Arr,代表数值不同的纸牌排成一条线，玩家A和玩家B依次拿走每张纸牌，
规定玩家A先拿，玩家B后拿，
但是每个玩家每次只能拿走最左或者最右的纸牌，
玩家A和玩家B都决定聪明。请返回最后获胜者的分数
10. N皇后问题  NQueue
在N*N的棋盘上要摆N个皇后，要求任何两个皇后不同行、不同列，也不在同一个斜线上
给定一个整数n,返回n皇后的摆法有多少种
通过位运算进行加速
时间复杂度 N^N
11. 假设有排成一行的N个位置，记为1~N, N一定大于等于2  RobotWalk
开始时机器人在其中的M位置上（M一定是1-N中的一个）
如果机器人来到1位置，那么只能往右移动来到2位置
如果机器人来到N位置，那么只能往左移动来到N-1位置
如果机器人需要来到中间位置，那么下一步可以往左走或者往右走
规定机器人必须走k步，最终才能来到P位置的方法有多少种
## 什么暴力递归可以继续优化
- 有重复调用同一个子问题的解，这种递归可以优化
- 如果每一个子问题都是不同的解，无法优化也不用去优化
## 常见的4种尝试模型
1. 从左往右的尝试模型
2. 范围上的尝试
3. 多样本位置全对应的尝试模型
4. 寻找业务限制的尝试模型
**不是所有的暴力递归都可以改成动态规划，而是所有的动态规划都来自于某个暴力递归**

# 动态规划
对于每一个题，先尝试暴递归，有重复解该动态规划。
- 可变参数，讲究组织：记忆化搜索 有枚举行为+精细化组织 -> 经典动态规划
- 可变参数，不讲究组织：普通递归
2^n => N * 表大小
自顶向下的动态规划
1. 给定一个数组，代表不同的面值，给出一个目标总数，返回达到目标钱数的总方法数 CoinsWay

递归的条件：
1. 可变的参数条件越少越好

给定一个字符串str,给定一个字符串类型的数组arr
arr里面的每一个字符串，代表一张贴纸，你可以把单个字符剪开使用，目的是拼出str来
返回至少需要多少张贴纸可以完成这个任务 StickersToSpellWord

## 什么暴力递归可以继续优化
1. 有重复调用同一个子问题的解，这种递归可以优化
2. 如果每一个子问题都是不同的解，没法优化
## 面试题和动态规划的关系
解决一个问题，可能有很多尝试
可能在很多尝试中，又有若干个尝试方法有动态规划的方式
一个问题可能有若干个动态规划的解法
## 如果找到某个问题的动态规划方式
1. 设计暴力递归 重要原则+4种常见尝试模型！**重点**
2. 分析有没有重复解，套路解决
3. 用记忆化搜索 ->是否枚举，建立空间感 用严格表结构实现动态规划，套路解决
4. 看看能否继续优化：套路解决
## 面试过程中暴力递归的原则
1. 每一个可变参数的类型，不要比int类型更加复杂
2. 原则1可以违反，让类型突破到一维线性结构，那必须是唯一可变参数
3. 如果发现原则1被违反，但不违反原则2，只需要做到记忆化搜索即可
4. 可变参数的个数，能少则少
## 知道了面试中设计暴力递归过程的原则，然后呢？
一定要逼自己找到不违反原则情况下的暴力尝试
如果你找到的暴力递归，不符合原则，马上舍弃，找新的！
如果某个题目突破了设计原则，一定极难极难，面试中概率低于5%
## 常见的四种尝试模型
1. 从左往右的尝试模型
2. 范围上的尝试模型
3. 多样本全位置对应的尝试模型
4. 寻找业务限制的尝试模型

多样本全位置 两个字符串的最长公共子序列问题   MaxSubSequence
寻找业务限制: 给定一个数组，代表每个人喝完准备刷杯子的时间，
只有一台咖啡机，一次只能洗一个杯子，时间耗费a,洗完才能洗下一杯。每个咖啡杯也可以自己挥发干净，时间耗费b,
咖啡杯可以并行挥发，返回让所有咖啡杯变干净的最早完成时间 Coffee
三个参数： int[] arr, int a, int b
