## 二叉树
先序遍历：任何子树的处理顺序是头左右
中序遍历：任何子树的处理顺序是左头右
后序遍历：任何子树的处理顺序是左右头

递归序：每个节点都会到达三次。第一次到达打印就是先序，第二次到达就是中序，第三次到达就是后序

非递归实现：
- 任何递归函数都可以改成非递归
- 自己设计压栈实现

实现：

先序遍历：
1. 弹出就打印
2. 如果有右孩子，压入右孩子
3. 如果有左孩子，压入左孩子

后序遍历：
1. 弹出就打印
2. 如果有左孩子，压入左孩子
3. 如果有右孩子，压入右孩子
结果逆序之后就是后序遍历的结果，做法就是准备一个辅助栈，输出结果

中序遍历：
1. 整条左边界依次入栈
2. 无法继续，弹出，然后执行条件1
结果逆序之后就是后序遍历的结果，做法就是准备一个辅助栈，输出结果

二叉树的层序遍历：
1. 宽度优先遍历，用队列
2. 设置flag变量，求出树的最大宽度

二叉树的反序列化与序列化
1. 可以用先序,后序，层序 实现二叉树的序列化,但中序没法实现，因为有可能遍历结果是相同的
2. 用什么样的序列化方式，就用什么样的方式反序列化

---
1. 遍历输出打印二叉树 RecursiveTraversalBT
2. 非递归遍历输出二叉树 UnRecursiveTraversalBT
3. 层序遍历-队列实现 LevelTraversalBT
4. 层序遍历-用变量实现 求二叉树的最大宽度 TreeMaxWidth
### 二叉树的递归套路
----
套路总结：
1. 假设以X节点为头，假设可以向X左树和X右树要任何信息
2. 在上一步的假设下，讨论以X节点为头，得到答案得可能性（重要）
3. 列出所有可能性后，确定到底需要向左树和右树要什么样的信息
4. 把左树和右树信息求全集，就是任何一棵子树都需要返回的信息S
5. 递归函数都返回S，每一颗子树都这么要求
6. 写代码，在代码中考虑如何把左树的信息和右树的信息整和出整棵树的信息
----

可以解决面试中的绝大多数的二叉树问题尤其是树形dp问题
本质是利用递归遍历二叉树的便利性
1. 如何设计一个打印整棵树的打印函数 PrintBinaryTree
2. 给定二叉树的某个节点，返回节点的后继节点  SuccessorNode
暴力解法：就是中序遍历，输出
降低时间复杂度为O(K)
    后继节点：中序遍历的情况， 某个节点的下一个节点为后续节点
3. 题目：PaperFolding
请把一段纸条放在桌子上，然后从纸条的下边往上方对折一次，压出折痕后展开。此时折痕是凹下去的，既折痕凸起的方向指向纸条的背面
如果从纸条的下方到上方连续对折两次，压出折痕后展开，此时有三条折痕。从上到下依次是下折痕，下折痕，上折痕。
给定一个输入参数N，代表纸条从下边向上方连续对折N次。请从上到下打印所有折痕的方向。
4. 给定一个二叉树的头结点head, 返回这棵二叉树是不是平衡二叉树  IsBalanced
平衡二叉树AVL：以它为节点的树，左子树和右子树的深度只差不超过1，且它的左右子树也都是平衡二叉树
5. 给定一棵二叉树的头节点head,任何两个节点之间的存在距离，返回二叉树的最大距离 MaxDistance
6. 给定一棵二叉树的头结点head,返回这棵二叉树最大的二叉搜索子树的节点数 MaxSubBSTSize
二叉搜索树：整棵树没有重复值，左树比头节点小，右树比头节点大，每棵子树都如此  
7. 派对的最大快乐值，员工的信息定义如下：
```java
class Employee {
    public int happy;// 这名员工的快乐值
    List<Employee> subordinates; // 这名员工有哪些直接下级
}
```

派对的最大快乐值：
公司的每个员工都符合Employee的描述。整个公司的人员结构可以看做是一棵
标准的、没有环的多叉树。树的头结点是公司的唯一老板。除老板之外每个员工都有唯一的直接上级。
叶节点是任何没有下属的基层员工，除基层员工之外，每个员工都有一个或多个直接下级

公司现在举办party,你可以决定哪些员工来，哪些员工不来，规则：
1. 如果某个员工来了，那么这个员工的所有直接下级都不能来
2. 派对的整体快乐值是所有到场员工的快乐值的累加
3. 目标让派对的整体快乐值尽量大
给定一棵多叉树的头结点boss,请返回派对的最大快乐值 MaxHappy